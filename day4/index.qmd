---
format:
  revealjs:
    incremental: false
    css: ../styles.css
execute: 
  echo: true
---

# 第4回：データの整理（１）

<https://data-science-chiba-2024.github.io/day4/>

## 連絡事項

- 第3回の宿題の締め切りを11月1日（金曜日） 23:59まで延長しました。

- 宿題のウエブサイトの容量を増やしました。

- 宿題のパッケージを[インストールするコード](https://joelnitta.github.io/joho-shori/day3/#/0/7)をアップデートしました。

## クイズ

:::: {.columns}

::: {.column width="50%"}
![](../images/joho2024-qr-code.png)
:::

::: {.column width="50%"}
**注意：** 質問は複数選択です。**すべて**の正しい答えを選んでください。
:::

::::

または、[gosocrative.com](https://gosocrative.com) で joho2024を入力

## データの整理（Data Wrangling）

- データが手に入ると、まだ解析に使えない状態であることが多いです。

- データの整理（「wrangling」）は**解析に使えるように整えるプロセス**です。
  - 元々はカウボーイが**牛を扱う技術**から来ています。

---

![Getty Images](https://media.istockphoto.com/id/172342607/photo/cattle-drive.jpg?s=612x612&w=0&k=20&c=Fz--vTqe2gMWKxbHvgdLCgfUveH_Y3-k0js5H1m9Snc=)

---

![Image by Allison Horst](https://datasciencecampus.github.io/DSCA_data_wrangling_with_r/slides/images/data_cowboy.png){fig-alt="data wrangling monsters"}

## 準備

- `students_analysis`プロジェクトを再度開きます。

. . .

- 新しいコマンドの勉強に進む前に、今までのスクリプトを少し変更したいと思います。

- 先のスライドで説明したように、データ解析を行う前に**データの整理が必要**なケースが多いです。

- 今回の`students.csv`に入っているデータもその一例です。

---

- そこで、`students.csv`を読み込む際には、まず`students_raw`という名前にしましょう。`raw`はこれが**生データ**（読み込んだデータのまま、何も手を加えていない状態）を示します。

```{r}
#| filename: students.R
#| eval: false
library(tidyverse)

# Load raw data
students_raw <- read_csv("data/students.csv")
```

```{r}
#| echo: false

library(tidyverse)

students_raw <- read_csv("../data/students.csv")
```

## データ整理の関数

これから学ぶ関数の共通点：

- データフレームを入力とし、データフレームを返す
- 最初の引数が入力のデータフレーム
- 他の引数は詳細（引数名に引用符を使わない）

`関数(データフレーム, 他の設定)` ➞ `データフレーム`

## データの整理：列名を整える

- データフレームの列名は任意ですが、使いやすい名前には以下の特徴があります：
  - 打ちやすい
  - 覚えやすい

- `` `Full Name` ``は打ちづらいです。`` ` ``もありますし、スペースも入っています。

- **おすすめ**：小文字のみを使用し、スペースの代わりに`_`を使う

## `rename()`で列名を変える

- `rename()`は列名を変更する関数です。
  - `新しい名前 = 前の名前`と指定します。

```{r}
#| attr-output: "style='font-size: 0.3em'"
rename(students_raw, full_name = `Full Name`)
``` 

---

![](../images/rename_annotated.png)

---

```{r}
#| attr-output: "style='font-size: 0.3em'"
rename(students_raw, full_name = `Full Name`)
``` 

- 注意：このようにしただけでは、元のデータは**変わっていません**。`<-`を使わない限り、関数の結果は保存されません。

## チャレンジ ①

`` `Student ID` ``という列を使いやすい列名に変更してください。

## `rename()`で列名を変える

- 複数の列名を変更する際は、コンマで区切って書きます。

---

```{r}
#| attr-output: "style='font-size: 0.3em'"
rename(
  students_raw,
  full_name = `Full Name`,
  student_id = `Student ID`
)
``` 

## 一気に列名を扱いやすくする

- 名前を一つずつ変更するのは手間がかかります。

- `clean_names()`という関数が列名を**一気に**きれいにしてくれます。
  - この関数は`tidyverse`に含まれていないパッケージ、`janitor`に入っているため、まずは`janitor`をロードする必要があります。

---

```{r}
#| attr-output: "style='font-size: 0.3em'"
library(janitor)
clean_names(students_raw)
``` 

---

これを`students_renamed`として保存しましょう。

```{r}
#| filename: students.R
#| eval: false
library(tidyverse)
library(janitor)

# Load raw data
students_raw <- read_csv("data/students.csv")

# Rename columns
students_renamed <- clean_names(students_raw)
```

```{r}
#| echo: false
students_renamed <- clean_names(students_raw)
```

## `mutate()`で列の中身を変える

- 「mutate」は「変化させる」という意味です。

- `age`は数字のはずですが、文字として読み込まれてしまいました。修正しましょう。

```{r}
#| attr-output: "style='font-size: 0.3em'"
mutate(students_renamed, age = parse_number(age))
```

---

- `parse_number()`は文字列を数字に変換する関数です。

- `Warning: 1 parsing failure`という注意が出ました。これは、データの中にうまく数字に変換できなかった値があったことを意味しています。

- 本当は修正した方が良いですが、少し上級な話になりますので今回は飛ばします。詳しく知りたい方は教科書を読んでいただくか、講義後に質問してください。

---

## きれいなデータを保存する

- これでデータが（ほとんど）整いましたので、`students`として保存します。

::: {.medsmall}

```{r}
#| filename: students.R
#| eval: false
library(tidyverse)
library(janitor)

# Load raw data
students_raw <- read_csv("data/students.csv")

# Rename columns
students_renamed <- clean_names(students_raw)

# Convert age to numeric
students <- mutate(students_renamed, age = parse_number(age))
```

:::

```{r}
#| echo: false

# Rename columns
students_renamed <- clean_names(students_raw)

# Convert age to numeric
students <- mutate(students_renamed, age = parse_number(age))
```

## `arrange()`で行を並び替える

- `arrange()`は行の順序を並び替える関数です。
  - 食事プラン（「`meal_plan`」）の順に並び替えましょう。

---

```{r}
#| attr-output: "style='font-size: 0.3em'"
arrange(students, meal_plan)
``` 

---

![](../images/arrange_annotated.png){height=300px}

## `arrange()`で行を並び替える

- デフォルト設定では、`arrange()`は小さい方から大きい方へと並び替えます。

- 逆の順にするには、列名を`desc()`の中に書きます。

```{r}
#| attr-output: "style='font-size: 0.3em'"
arrange(students, desc(meal_plan))
``` 

## チャレンジ ②

学生の**名前の順**に並び替えてください。

## `filter()`で行を絞り込む

- 生データが必要以上に多い場合がよくあります（特に「ビッグデータ」を扱っているとき）。

- `filter()`で条件を設定し、その行だけに絞り込みます。

---

```{r}
#| attr-output: "style='font-size: 0.3em'"
filter(students, student_id < 4)
```

- 行の数が変わったことを確認できますか？

## データの比較

データの比較を行う主な記号：

- `>` より大きい
- `<` より小さい
- `==` イコール（`=`ではありません！）
- `|` あるいは
- `&` そして（複数条件の指定）

比較の記号のアウトプットは**論理ベクトル**です。

---

```{r}
11 > 10
```

---

```{r}
c(1, 2, 3, 4, 5, 6) > 4
```

---

```{r}
11 == 11
```

---

```{r}
#| error: TRUE
11 = 11
```

## チャレンジ ③

`students`の中から食事プランが`"Lunch only"`になっている学生に絞り込んでから、名前をZからAの順で並び替えてください。

## パイプについて

- チャレンジ ③では、条件で絞ったデータを一旦保存してから、次のステップ（列の並び替え）を行いました。

```{r}
#| attr-output: "style='font-size: 0.3em'"
students_lunch <- filter(students, meal_plan == "Lunch only")
arrange(students_lunch, desc(full_name))
``` 

## パイプについて

- これは解析が短い場合は大丈夫かもしれませんが、長くなると**大変です**。

- **パイプ**というものがこの問題を解決します。

## パイプの使い方

- まずはパイプ（`|>`）の基本的な使い方を覚えましょう。
  - 以前は`%>%`と書きましたが、最近のRでは`|>`と書きます。

- `arrange(データ, 列名)`というような書き方をしてきましたが、パイプを使うとこのように書きます：

`データ |> arrange(列名)`

---

- つまり、`|>`は**左側のものを右側へ渡す**機能があります。

使ってみましょう。

```{r}
#| attr-output: "style='font-size: 0.3em'"
students |> arrange(meal_plan)
``` 

---

- 繰り返しになりますが、

`students |> arrange(meal_plan)`

と

`arrange(students, meal_plan)`

は**同じです**。

---

- パイプの便利な点は、**途中結果を保存することなく**解析のステップを次から次へと進めることができる点です。

::: {.medsmall}

```{r}
students |> filter(meal_plan == "Lunch only") |> arrange(full_name)
``` 

:::

---

- Rは改行があっても構いませんので、改行を入れるともっと読みやすくなります。

```{r}
#| attr-output: "style='font-size: 0.3em'"
students |>
  filter(meal_plan == "Lunch only") |>
  arrange(full_name)
``` 

---

```{r}
#| eval: false
students |>
  filter(meal_plan == "Lunch only") |>
  arrange(full_name)
``` 

`|>` を見たら、「それから」と読みます：

*`students`から始めて、**それから**食事プランが"Lunch only"となっている学生に絞り込んで、**それから**学生の名前順に並び替える*

---

- これからは基本的にパイプを使ってコードを書きます。
  - 最初は違和感があるかもしれませんが、すぐに慣れるでしょう。

## 欠測データについて

- `age`には`NA`という値が入っています。

- `NA`は英語で「Not Applicable」（「該当しない」）という意味です。
  - つまり、そのデータは該当しないか、あるいは欠損しているという意味です。
  - `age`の場合は何らかの理由でその人の年齢が分からないということです。
  - （一つはうまく数字への変換ができなかったためですが、もう一つは元々そうなっていました）

## 欠測データを省く方法

- 欠測データがデータフレームに含まれていると、エラーの原因になることが多いです。
  - 解析を行う前にそれを除外する必要があります。
  - `is.na()`関数はその値が`NA`であるかどうかを教えてくれます。

- 例えば：

```{r}
is.na(c(1, 2, NA, 3))
```

---

では、使ってみましょう。

```{r}
#| attr-output: "style='font-size: 0.3em'"
students |>
  filter(is.na(age))
```

あらら。これはちょっとまずいですね。欠測データ**だけ**に絞られてしまいました。

私たちが欲しいのは、その**逆**です。

---

- `!`は論理ベクトルを**反転**させます。
  - つまり、`TRUE`を`FALSE`に、`FALSE`を`TRUE`にします。「否」と読めば良いです。

```{r}
!is.na(c(1, 2, NA, 3))
```

---

- `!`を使って`NA`**ではない**データだけに絞り込みましょう。

```{r}
#| attr-output: "style='font-size: 0.3em'"
students |>
  filter(!is.na(age))
```

## チャレンジ ④

`students`から`age`が`NA`になっている行を除外してから、`favorite_food`の順で並び替えてください。（パイプを使ってください）

## まとめ

- データを読み込んだ後、整える必要があります。
- `rename()`は列の名前を変更する。
- `arrange()`は行を並び替える。
- `mutate()`は列の中身を変える。
- `filter()`は行を絞り込む。
- `|>`（パイプ）を使うと、複数の操作を連続して行うことができます。
